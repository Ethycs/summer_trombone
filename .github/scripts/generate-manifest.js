import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import { fileURLToPath } from 'url';
import crypto from 'crypto';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const contentRoot = 'blog';
const subdirectories = ['papers', 'posts'];
const outputFile = path.join('system', 'filesystem.json'); // Output to system/filesystem.json

// Load existing manifest to preserve summaries
let existingManifest = {};
if (fs.existsSync(outputFile)) {
    try {
        existingManifest = JSON.parse(fs.readFileSync(outputFile, 'utf8'));
    } catch (error) {
        console.warn('Could not parse existing manifest. Starting fresh.');
    }
}

const manifest = {
    files: {},
    lastUpdated: new Date().toISOString()
};

function getGitFirstCommitDate(filePath) {
    try {
        const command = `git log --follow --format=%aD "${filePath}" | tail -n 1`;
        const dateStr = execSync(command).toString().trim();
        return new Date(dateStr).toISOString();
    } catch (error) {
        console.warn(`Could not get first commit date for ${filePath}. Using file creation time.`);
        return fs.statSync(filePath).birthtime.toISOString();
    }
}

function getGitLastCommitDate(filePath) {
    try {
        const command = `git log -1 --format=%aD "${filePath}"`;
        const dateStr = execSync(command).toString().trim();
        return new Date(dateStr).toISOString();
    } catch (error) {
        console.warn(`Could not get last commit date for ${filePath}. Using file modification time.`);
        return fs.statSync(filePath).mtime.toISOString();
    }
}

function getFileId(filePath) {
    return path.relative(process.cwd(), filePath)
        .replace(/\.tex$|\.md$/, '')
        .replace(/[\/\\]/g, '-');
}

function getFileHash(filePath) {
    const content = fs.readFileSync(filePath);
    return crypto.createHash('sha256').update(content).digest('hex');
}

console.log(`Starting manifest generation for content inside './${contentRoot}'...`);

subdirectories.forEach(subdir => {
    const searchPath = path.join(process.cwd(), contentRoot, subdir);

    if (!fs.existsSync(searchPath)) {
        console.warn(`Directory not found: ${searchPath}. Skipping.`);
        return;
    }

    const files = fs.readdirSync(searchPath);

    files.forEach(file => {
        const fullFilePath = path.join(searchPath, file);
        const stats = fs.statSync(fullFilePath);

        if (stats.isFile() && (file.endsWith('.tex') || file.endsWith('.md'))) {
            const fileId = getFileId(fullFilePath);
            const virtualPath = `/${contentRoot}/${subdir}/${file}`;
            const currentHash = getFileHash(fullFilePath);

            // Check existing entry
            const existingEntry = existingManifest.files && existingManifest.files[fileId];
            const contentChanged = !existingEntry || existingEntry.contentHash !== currentHash;
            
            manifest.files[fileId] = {
                id: fileId,
                path: virtualPath,
                type: file.endsWith('.tex') ? 'TeX Article' : 'Markdown Post',
                created: existingEntry ? existingEntry.created : getGitFirstCommitDate(fullFilePath),
                modified: contentChanged ? new Date().toISOString() : (existingEntry ? existingEntry.modified : getGitLastCommitDate(fullFilePath)),
                contentHash: currentHash
            };
            
            // Preserve summary if content hasn't changed
            if (existingEntry && existingEntry.summary && !contentChanged) {
                manifest.files[fileId].summary = existingEntry.summary;
                console.log(`Preserved: ${fileId} (content unchanged)`);
            } else if (existingEntry && contentChanged) {
                console.log(`Changed: ${fileId} (content hash changed)`);
                // Summary will be generated by summarize-manifest.js
                // But preserve old summary until new one is generated
                if (existingEntry.summary) {
                    manifest.files[fileId].summary = existingEntry.summary;
                }
            } else {
                console.log(`New: ${fileId}`);
            }
        }
    });
});

try {
    fs.writeFileSync(outputFile, JSON.stringify(manifest, null, 2));
    console.log(`Manifest successfully generated at '${outputFile}'`);
    console.log(JSON.stringify(manifest, null, 2));
} catch (error) {
    console.error(`Error writing manifest file: ${error.message}`);
    process.exit(1);
}